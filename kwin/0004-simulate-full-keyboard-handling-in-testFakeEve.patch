From a36dec536e4c3c890c34312646bac056fe1ed89d Mon Sep 17 00:00:00 2001
From: David Edmundson <kde@davidedmundson.co.uk>
Date: Wed, 27 Aug 2025 15:03:28 +0100
Subject: [PATCH 1/2] tests: Simulate full keyboard handling in
 testFakeEventFallback

The current test monitors a key event, then matches against received key
codes. This does not correctly simulate real client behaivour. We need
to track keymaps and modifiers.

A few things were wrong:
- The handling of the capital "A" is
currently incorrect, as we need the shift to be set as a modifier, not
as a key.
- QKeySequenceFromText does not extract all the letters from a given
string, it's for extracting things in the form "control+l" which isn't
what we have here
- It didn't handle UTF-16
- If a keysym doesn't exist in our current we need to switch the layout
---
 autotests/integration/CMakeLists.txt          |  1 +
 autotests/integration/inputmethod_test.cpp    | 62 +++-----------
 autotests/integration/kwin_wayland_test.cpp   | 77 +++++++++++++++++
 autotests/integration/kwin_wayland_test.h     | 30 ++++++-
 src/inputmethod.cpp                           | 83 +++++++++----------
 .../buttonrebinds/buttonrebindsfilter.cpp     | 13 ++-
 src/xkb.cpp                                   | 60 +++++++++++++-
 src/xkb.h                                     | 14 +++-
 8 files changed, 234 insertions(+), 106 deletions(-)

diff --git a/autotests/integration/CMakeLists.txt b/autotests/integration/CMakeLists.txt
index 4c903e2961..772fed90cd 100644
--- a/autotests/integration/CMakeLists.txt
+++ b/autotests/integration/CMakeLists.txt
@@ -47,6 +47,7 @@ target_link_libraries(KWinIntegrationTestFramework
         Wayland::Client
         Libdrm::Libdrm
         kwin
+        XKB::XKB
 
     PRIVATE
         # Static plugins
diff --git a/autotests/integration/inputmethod_test.cpp b/autotests/integration/inputmethod_test.cpp
index 16c61dd4d1..3bf2446b13 100644
--- a/autotests/integration/inputmethod_test.cpp
+++ b/autotests/integration/inputmethod_test.cpp
@@ -39,6 +39,7 @@
 #include <KWayland/Client/surface.h>
 #include <KWayland/Client/textinput.h>
 #include <linux/input-event-codes.h>
+#include <sys/mman.h>
 
 using namespace KWin;
 using KWin::VirtualKeyboardDBus;
@@ -682,59 +683,22 @@ void InputMethodTest::testFakeEventFallback()
     kwinApp()->inputMethod()->setActive(true);
     QVERIFY(inputMethodActiveSpy.count() || inputMethodActiveSpy.wait());
 
-    // Without a way to communicate to the client, we send fake key events. This
-    // means the client needs to be able to receive them, so create a keyboard for
-    // the client and listen whether it gets the right events.
-    auto keyboard = Test::waylandSeat()->createKeyboard(window);
-    QSignalSpy keySpy(keyboard, &KWayland::Client::Keyboard::keyChanged);
-
+    auto keyboard = new Test::SimpleKeyboard(window);
     auto context = Test::inputMethod()->context();
     QVERIFY(context);
 
-    // First, send a simple one-character string and check to see if that
-    // generates a key press followed by a key release on the client side.
-    zwp_input_method_context_v1_commit_string(context, 0, "a");
-
-    keySpy.wait();
-    QVERIFY(keySpy.count() == 2);
-
-    auto compare = [](const QList<QVariant> &input, quint32 key, KWayland::Client::Keyboard::KeyState state) {
-        auto inputKey = input.at(0).toInt();
-        auto inputState = input.at(1).value<KWayland::Client::Keyboard::KeyState>();
-        QCOMPARE(inputKey, key);
-        QCOMPARE(inputState, state);
-    };
-
-    compare(keySpy.at(0), KEY_A, KWayland::Client::Keyboard::KeyState::Pressed);
-    compare(keySpy.at(1), KEY_A, KWayland::Client::Keyboard::KeyState::Released);
-
-    keySpy.clear();
-
-    // Capital letters are recognised and sent as a combination of Shift + the
-    // letter.
-
-    zwp_input_method_context_v1_commit_string(context, 0, "A");
+    zwp_input_method_context_v1_commit_string(context, 0, "aB Ã¤Ã„ ì•ˆ ðŸ˜Š");
 
-    keySpy.wait();
-    QVERIFY(keySpy.count() == 4);
-
-    compare(keySpy.at(0), KEY_LEFTSHIFT, KWayland::Client::Keyboard::KeyState::Pressed);
-    compare(keySpy.at(1), KEY_A, KWayland::Client::Keyboard::KeyState::Pressed);
-    compare(keySpy.at(2), KEY_A, KWayland::Client::Keyboard::KeyState::Released);
-    compare(keySpy.at(3), KEY_LEFTSHIFT, KWayland::Client::Keyboard::KeyState::Released);
-
-    keySpy.clear();
-
-    // Special keys are not sent through commit_string but instead use keysym.
-    auto enter = input()->keyboard()->xkb()->toKeysym(KEY_ENTER);
-    zwp_input_method_context_v1_keysym(context, 0, 0, enter, uint32_t(WL_KEYBOARD_KEY_STATE_PRESSED), 0);
-    zwp_input_method_context_v1_keysym(context, 0, 1, enter, uint32_t(WL_KEYBOARD_KEY_STATE_RELEASED), 0);
-
-    keySpy.wait();
-    QVERIFY(keySpy.count() == 2);
-
-    compare(keySpy.at(0), KEY_ENTER, KWayland::Client::Keyboard::KeyState::Pressed);
-    compare(keySpy.at(1), KEY_ENTER, KWayland::Client::Keyboard::KeyState::Released);
+    QSignalSpy receivedTextChangedSpy(keyboard, &Test::SimpleKeyboard::receviedTextChanged);
+    bool matched = false;
+    for (int i = 0; i < 100; ++i) {
+        if (keyboard->receviedText() == "aB Ã¤Ã„ ì•ˆ ðŸ˜Š") {
+            matched = true;
+            break;
+        }
+        receivedTextChangedSpy.wait();
+    }
+    QVERIFY(matched);
 
     shellSurface.reset();
     QVERIFY(Test::waitForWindowClosed(window));
diff --git a/autotests/integration/kwin_wayland_test.cpp b/autotests/integration/kwin_wayland_test.cpp
index 6ad554d585..9429455159 100644
--- a/autotests/integration/kwin_wayland_test.cpp
+++ b/autotests/integration/kwin_wayland_test.cpp
@@ -20,6 +20,8 @@
 #include "wayland_server.h"
 #include "workspace.h"
 
+#include <KWayland/Client/seat.h>
+
 #if KWIN_BUILD_X11
 #include "utils/xcbutils.h"
 #include "xwayland/xwayland.h"
@@ -37,6 +39,7 @@
 // system
 #include <iostream>
 #include <ranges>
+#include <sys/mman.h>
 #include <sys/socket.h>
 #include <unistd.h>
 
@@ -317,6 +320,80 @@ void Test::setOutputConfig(const QList<OutputInfo> &infos)
     }
     workspace()->applyOutputConfiguration(config, outputs);
 }
+
+Test::SimpleKeyboard::SimpleKeyboard(QObject *parent)
+    : QObject(parent)
+    , m_keyboard(Test::waylandSeat()->createKeyboard(parent))
+{
+    static const int EVDEV_OFFSET = 8;
+
+    connect(m_keyboard, &KWayland::Client::Keyboard::keymapChanged, this, [this](int fd, uint32_t size) {
+        char *map_shm = static_cast<char *>(
+            mmap(nullptr, size, PROT_READ, MAP_SHARED, fd, 0));
+        close(fd);
+
+        Q_ASSERT(map_shm != MAP_FAILED);
+
+        m_keymap = XkbKeymapPtr(
+            xkb_keymap_new_from_string(
+                m_ctx.get(),
+                map_shm,
+                XKB_KEYMAP_FORMAT_TEXT_V1,
+                XKB_KEYMAP_COMPILE_NO_FLAGS),
+            &xkb_keymap_unref);
+
+        munmap(map_shm, size);
+        Q_ASSERT(m_keymap);
+
+        m_state = XkbStatePtr(xkb_state_new(m_keymap.get()), &xkb_state_unref);
+        Q_ASSERT(m_state);
+    });
+
+    connect(m_keyboard, &KWayland::Client::Keyboard::modifiersChanged, this, [this](quint32 depressed, quint32 latched, quint32 locked, quint32 group) {
+        if (!m_state) {
+            return;
+        }
+        xkb_state_update_mask(
+            m_state.get(),
+            depressed,
+            latched,
+            locked,
+            0, 0,
+            group);
+    });
+
+    connect(m_keyboard, &KWayland::Client::Keyboard::keyChanged, this, [this](quint32 key, KWayland::Client::Keyboard::KeyState state, quint32 time) {
+        if (!m_state) {
+            return;
+        }
+
+        xkb_keycode_t kc = key + EVDEV_OFFSET;
+
+        if (state == KWayland::Client::Keyboard::KeyState::Pressed) {
+            const xkb_keysym_t *syms;
+            int nsyms = xkb_state_key_get_syms(m_state.get(), kc, &syms);
+            for (int i = 0; i < nsyms; i++) {
+                char buf[64];
+                int len = xkb_keysym_to_utf8(syms[i], buf, sizeof(buf));
+                if (len > 1) {
+                    m_receviedText.append(QString::fromUtf8(buf, len - 1)); // xkb_keysym_to_utf8 contains terminating byte
+                    Q_EMIT receviedTextChanged();
+                }
+                Q_EMIT keySymRecevied(syms[i]);
+            }
+        }
+    });
+}
+
+KWayland::Client::Keyboard *Test::SimpleKeyboard::keyboard()
+{
+    return m_keyboard;
+}
+
+QString Test::SimpleKeyboard::receviedText()
+{
+    return m_receviedText;
+}
 }
 
 #include "moc_kwin_wayland_test.cpp"
diff --git a/autotests/integration/kwin_wayland_test.h b/autotests/integration/kwin_wayland_test.h
index c7e7004199..9350a0eb5e 100644
--- a/autotests/integration/kwin_wayland_test.h
+++ b/autotests/integration/kwin_wayland_test.h
@@ -13,13 +13,18 @@
 #include "main.h"
 #include "window.h"
 
+// KWayland
+#include <KWayland/Client/keyboard.h>
+#include <KWayland/Client/surface.h>
+
 // Qt
 #include <QSignalSpy>
 #include <QTest>
 
-#include <KWayland/Client/surface.h>
 #include <optional>
 
+#include <xkbcommon/xkbcommon.h>
+
 #include "qwayland-color-management-v1.h"
 #include "qwayland-cursor-shape-v1.h"
 #include "qwayland-fake-input.h"
@@ -1055,6 +1060,29 @@ public:
     }
 };
 
+using XkbContextPtr = std::unique_ptr<xkb_context, decltype(&xkb_context_unref)>;
+using XkbKeymapPtr = std::unique_ptr<xkb_keymap, decltype(&xkb_keymap_unref)>;
+using XkbStatePtr = std::unique_ptr<xkb_state, decltype(&xkb_state_unref)>;
+
+class SimpleKeyboard : public QObject
+{
+    Q_OBJECT
+public:
+    explicit SimpleKeyboard(QObject *parent = nullptr);
+    KWayland::Client::Keyboard *keyboard();
+    QString receviedText();
+Q_SIGNALS:
+    void receviedTextChanged();
+    void keySymRecevied(xkb_keysym_t keysym);
+
+private:
+    KWayland::Client::Keyboard *m_keyboard;
+    QString m_receviedText;
+    XkbContextPtr m_ctx = XkbContextPtr(xkb_context_new(XKB_CONTEXT_NO_FLAGS), &xkb_context_unref);
+    XkbKeymapPtr m_keymap{nullptr, &xkb_keymap_unref};
+    XkbStatePtr m_state{nullptr, &xkb_state_unref};
+};
+
 struct OutputInfo
 {
     QRect geometry;
diff --git a/src/inputmethod.cpp b/src/inputmethod.cpp
index d7bd243220..959c81af1d 100644
--- a/src/inputmethod.cpp
+++ b/src/inputmethod.cpp
@@ -54,39 +54,29 @@
 namespace KWin
 {
 
-static std::vector<quint32> textToKey(const QString &text)
+static QList<xkb_keysym_t> textToKey(const QString &inputString)
 {
-    if (text.isEmpty()) {
-        return {};
-    }
-
-    auto sequence = QKeySequence::fromString(text);
-    if (sequence.isEmpty()) {
-        return {};
-    }
+    QList<xkb_keysym_t> result;
 
-    const QList<xkb_keysym_t> syms = KWin::Xkb::keysymsFromQtKey(sequence[0]);
-    if (syms.empty()) {
-        return {};
-    }
+    for (int i = 0; i < inputString.size(); ++i) {
+        char32_t cp = inputString[i].unicode();
 
-    std::optional<xkb_keycode_t> keyCode;
-    for (xkb_keysym_t sym : syms) {
-        auto code = input()->keyboard()->xkb()->keycodeFromKeysym(sym);
-        if (code) {
-            keyCode = code->first;
-            break;
+        // Handle surrogate pair (two QChars â†’ one codepoint)
+        if (inputString[i].isHighSurrogate() && i + 1 < inputString.size()
+            && inputString[i + 1].isLowSurrogate()) {
+            cp = QChar::surrogateToUcs4(inputString[i].unicode(),
+                                        inputString[i + 1].unicode());
+            i++; // skip the low surrogate
         }
-    }
-    if (!keyCode) {
-        return {};
-    }
 
-    if (text.isUpper()) {
-        return {KEY_LEFTSHIFT, quint32(keyCode.value())};
+        xkb_keysym_t ks = xkb_utf32_to_keysym(cp);
+        if (ks != XKB_KEY_NoSymbol) {
+            result.append(ks);
+        } else {
+            qCWarning(KWIN_VIRTUALKEYBOARD) << "No keysym for U+" << &std::hex << (int)cp << "\n";
+        }
     }
-
-    return {quint32(keyCode.value())};
+    return result;
 }
 
 InputMethod::InputMethod()
@@ -634,27 +624,32 @@ void InputMethod::commitString(qint32 serial, const QString &text)
         // The application has no way of communicating with the input method.
         // So instead, try to convert what we get from the input method into
         // keycodes and send those as fake input to the client.
-        auto keys = textToKey(text);
-        if (keys.empty()) {
-            return;
-        }
+
+        const QList<xkb_keysym_t> keySyms = textToKey(text);
 
         // First, send all the extracted keys as pressed keys to the client.
-        for (const auto &key : keys) {
-            waylandServer()->seat()->notifyKeyboardKey(key, KeyboardKeyState::Pressed);
+        for (const xkb_keysym_t &keySym : keySyms) {
+            std::optional<Xkb::KeyCode> keyCode = input()->keyboard()->xkb()->keycodeFromKeysym(keySym);
+            if (!keyCode) {
+                qCWarning(KWIN_VIRTUALKEYBOARD) << "Could not map keysym " << keySym << "to keycode. Trying custom keymap";
+                static const uint unmappedKeyCode = 247;
+                auto temporaryKeymap = input()->keyboard()->xkb()->createKeymapForKeysym(unmappedKeyCode, keySym);
+                if (temporaryKeymap.isEmpty()) {
+                    continue;
+                }
+                waylandServer()->seat()->keyboard()->setKeymap(temporaryKeymap);
+                waylandServer()->seat()->notifyKeyboardKey(unmappedKeyCode, KeyboardKeyState::Pressed);
+                waylandServer()->seat()->notifyKeyboardKey(unmappedKeyCode, KeyboardKeyState::Released);
+                waylandServer()->seat()->keyboard()->setKeymap(input()->keyboard()->xkb()->keymapContents());
+            } else {
+                waylandServer()->seat()->notifyKeyboardModifiers(keyCode->modifiers, 0, 0, input()->keyboard()->xkb()->currentLayout());
+                waylandServer()->seat()->notifyKeyboardKey(keyCode->keyCode, KeyboardKeyState::Pressed);
+                waylandServer()->seat()->notifyKeyboardKey(keyCode->keyCode, KeyboardKeyState::Released);
+            }
         }
 
-        // Then, send key release for those keys in reverse.
-        for (auto itr = keys.rbegin(); itr != keys.rend(); ++itr) {
-            // Since we are faking key events, we do not have distinct press/release
-            // events. So instead, just queue the button release so it gets sent
-            // a few moments after the press.
-            auto key = *itr;
-            QMetaObject::invokeMethod(
-                this, [key]() {
-                waylandServer()->seat()->notifyKeyboardKey(key, KeyboardKeyState::Released);
-            }, Qt::QueuedConnection);
-        }
+        // reset any modifiers to the actual state
+        input()->keyboard()->xkb()->forwardModifiers();
     }
 }
 
diff --git a/src/plugins/buttonrebinds/buttonrebindsfilter.cpp b/src/plugins/buttonrebinds/buttonrebindsfilter.cpp
index 80b20db171..f122b32298 100644
--- a/src/plugins/buttonrebinds/buttonrebindsfilter.cpp
+++ b/src/plugins/buttonrebinds/buttonrebindsfilter.cpp
@@ -380,25 +380,22 @@ bool ButtonRebindsFilter::sendKeySequence(const QKeySequence &keys, bool pressed
         qCWarning(KWIN_BUTTONREBINDS) << "Could not convert" << keys << "to keysym";
         return false;
     }
+    std::optional<KWin::Xkb::KeyCode> code;
     // KKeyServer returns upper case syms, lower it to not confuse modifiers handling
-    std::optional<int> keyCode;
-    std::optional<int> level;
     for (int sym : syms) {
-        auto code = KWin::input()->keyboard()->xkb()->keycodeFromKeysym(sym);
+        code = KWin::input()->keyboard()->xkb()->keycodeFromKeysym(sym);
         if (code) {
-            keyCode = code->first;
-            level = code->second;
             break;
         }
     }
-    if (!keyCode) {
+    if (!code) {
         qCWarning(KWIN_BUTTONREBINDS) << "Could not convert" << keys << "syms: " << syms << "to keycode";
         return false;
     }
 
     RebindScope scope;
 
-    if (key & Qt::ShiftModifier || level == 1) {
+    if (key & Qt::ShiftModifier || code->level == 1) {
         sendKey(KEY_LEFTSHIFT);
     }
     if (key & Qt::ControlModifier) {
@@ -411,7 +408,7 @@ bool ButtonRebindsFilter::sendKeySequence(const QKeySequence &keys, bool pressed
         sendKey(KEY_LEFTMETA);
     }
 
-    sendKey(keyCode.value());
+    sendKey(code->keyCode);
     return true;
 }
 
diff --git a/src/xkb.cpp b/src/xkb.cpp
index 0cf6ac5816..a8e5266128 100644
--- a/src/xkb.cpp
+++ b/src/xkb.cpp
@@ -30,6 +30,9 @@
 #include <sys/mman.h>
 #include <unistd.h>
 
+#include <format>
+#include <string>
+
 // TODO: drop these ifdefs when xkbcommon >= 1.8.0 is required
 #ifndef XKB_LED_NAME_COMPOSE
 #define XKB_LED_NAME_COMPOSE "Compose"
@@ -1236,7 +1239,7 @@ void Xkb::setSeat(SeatInterface *seat)
     m_seat = QPointer<SeatInterface>(seat);
 }
 
-std::optional<std::pair<int, int>> Xkb::keycodeFromKeysym(xkb_keysym_t keysym)
+std::optional<Xkb::KeyCode> Xkb::keycodeFromKeysym(xkb_keysym_t keysym)
 {
     if (!m_keymap || !m_state) {
         return {};
@@ -1250,7 +1253,16 @@ std::optional<std::pair<int, int>> Xkb::keycodeFromKeysym(xkb_keysym_t keysym)
             uint num_syms = xkb_keymap_key_get_syms_by_level(m_keymap, keycode, layout, currentLevel, &syms);
             for (uint sym = 0; sym < num_syms; sym++) {
                 if (syms[sym] == keysym) {
-                    return {{keycode - EVDEV_OFFSET, currentLevel}};
+
+                    xkb_mod_mask_t masks[1]; // this function returns every way to shift to this level, we just need 1
+                    int nMasks = xkb_keymap_key_get_mods_for_level(
+                        m_keymap, keycode, layout, currentLevel,
+                        masks, 1);
+                    xkb_mod_mask_t modifiers = 0;
+                    if (nMasks > 0) {
+                        modifiers = masks[0];
+                    }
+                    return Xkb::KeyCode({keycode - EVDEV_OFFSET, currentLevel, modifiers});
                 }
             }
         }
@@ -1307,6 +1319,50 @@ QList<xkb_keysym_t> Xkb::keysymsFromQtKey(QKeyCombination keyQt)
     }
     return syms;
 }
+
+QByteArray Xkb::createKeymapForKeysym(xkb_keycode_t newKeycode,
+                                      xkb_keysym_t customSym)
+{
+    char symName[64];
+    if (xkb_keysym_get_name(customSym, symName, sizeof(symName)) <= 0) {
+        qWarning() << "Could not find name for keysym" << customSym;
+        return {};
+    }
+
+    const int keycode = newKeycode + EVDEV_OFFSET;
+
+    const QString keyMapString = QString::asprintf(
+        R"eof(xkb_keymap {
+  xkb_keycodes "custom" {
+    <CSTM> = %d;
+  };
+  xkb_types "(custom)" { include "complete" };
+  xkb_compatibility "custom" { include "complete" };
+  xkb_symbols "custom" {
+    include "pc+us"
+    key <CSTM> { [ %s ] };
+  };
+};
+)eof",
+        keycode, symName);
+
+    struct xkb_keymap *newMap =
+        xkb_keymap_new_from_string(m_context,
+                                   keyMapString.toLatin1().constData(),
+                                   XKB_KEYMAP_FORMAT_TEXT_V1,
+                                   XKB_KEYMAP_COMPILE_NO_FLAGS);
+
+    if (!newMap) {
+        qWarning() << "Could not create new keymap for keysym" << customSym;
+        return {};
+    }
+
+    UniqueCPtr<char> keymapString(xkb_keymap_get_as_string(newMap, XKB_KEYMAP_FORMAT_TEXT_V1));
+    if (!keymapString) {
+        return {};
+    }
+    return keymapString.get();
+}
 }
 
 #include "moc_xkb.cpp"
diff --git a/src/xkb.h b/src/xkb.h
index 2da99a0005..de97d0b8c8 100644
--- a/src/xkb.h
+++ b/src/xkb.h
@@ -124,7 +124,13 @@ public:
     /**
      * Returns a pair of <keycode, level> for the given keysym.
      */
-    std::optional<std::pair<int, int>> keycodeFromKeysym(xkb_keysym_t keysym);
+    struct KeyCode
+    {
+        xkb_keycode_t keyCode = 0;
+        uint level = 0;
+        xkb_mod_mask_t modifiers = 0;
+    };
+    std::optional<KeyCode> keycodeFromKeysym(xkb_keysym_t keysym);
 
     /**
      * Returns list of candidate keysyms corresponding to the given Qt key.
@@ -133,6 +139,10 @@ public:
      */
     static QList<xkb_keysym_t> keysymsFromQtKey(QKeyCombination keyQt);
 
+    // Create a new keymap with one custom keysym bound to a given keycode.
+    QByteArray createKeymapForKeysym(xkb_keycode_t newKeycode,
+                                     xkb_keysym_t customSym);
+
 public Q_SLOTS:
     void reconfigure();
 
@@ -179,7 +189,7 @@ private:
     KConfigGroup m_configGroup;
     KSharedConfigPtr m_numLockConfig;
 
-    struct
+    struct ModifierState
     {
         xkb_mod_index_t depressed = 0;
         xkb_mod_index_t latched = 0;
-- 
2.50.1

